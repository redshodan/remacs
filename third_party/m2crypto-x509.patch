--- SWIG/_x509.i.org	2011-10-30 10:12:00.926720001 -0600
+++ SWIG/_x509.i	2011-10-30 10:43:45.386720000 -0600
@@ -11,6 +11,7 @@
 
 %{
 #include <openssl/x509.h>
+#include <openssl/x509_vfy.h>
 #include <openssl/x509v3.h>
 %}
 
@@ -379,6 +380,60 @@
 }
 %}
 
+%{
+static int verify_cert_cb(int ok, X509_STORE_CTX *ctx)
+{
+    int cert_error = X509_STORE_CTX_get_error(ctx);
+    X509 *current_cert = X509_STORE_CTX_get_current_cert(ctx);
+
+    if (!ok)
+    {
+/*        if (current_cert)
+        {
+            X509_NAME_print_ex_fp(stdout,
+                                  X509_get_subject_name(current_cert),
+                                  0, XN_FLAG_ONELINE);
+            printf("\n");
+        }
+        printf("error %d at %d depth lookup:%s\n",
+               cert_error,
+               X509_STORE_CTX_get_error_depth(ctx),
+               X509_verify_cert_error_string(cert_error));*/
+        switch(cert_error)
+        {
+        case X509_V_ERR_NO_EXPLICIT_POLICY:
+/*            printf("error: no explicit policy\n");*/
+        case X509_V_ERR_CERT_HAS_EXPIRED:
+            
+            /* since we are just checking the certificates, it is
+             * ok if they are self signed. But we should still warn
+             * the user.
+             */
+
+        case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
+            /* Continue after extension errors too */
+        case X509_V_ERR_INVALID_CA:
+        case X509_V_ERR_INVALID_NON_CA:
+        case X509_V_ERR_PATH_LENGTH_EXCEEDED:
+        case X509_V_ERR_INVALID_PURPOSE:
+        case X509_V_ERR_CRL_HAS_EXPIRED:
+        case X509_V_ERR_CRL_NOT_YET_VALID:
+        case X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION:
+            ok = 1;
+        }
+        
+        return ok;
+        
+    }
+    /* if (cert_error == X509_V_OK && ok == 2) */
+    /* { */
+    /*     printf("ok == 2\n"); */
+    /* } */
+    ERR_clear_error();
+    return(ok);
+}
+%}
+
 %threadallow x509_crl_read_pem;
 %inline %{
 X509_CRL *x509_crl_read_pem(BIO *bio) {
@@ -604,6 +659,42 @@
   return X509_STORE_CTX_get_app_data(ctx);
 }
 
+int verify_cert(STACK_OF(X509) *tstack, X509 *x)
+{
+    int ret = 0;
+	X509_STORE *cert_ctx;
+	X509_STORE_CTX *csc;
+
+	cert_ctx=X509_STORE_new();
+	if (cert_ctx == NULL)
+    {
+		return 0;
+    }
+	X509_STORE_set_verify_cb_func(cert_ctx, verify_cert_cb);
+	csc = X509_STORE_CTX_new();
+	if (csc == NULL)
+    {
+        X509_STORE_free(cert_ctx);
+		return 0;
+    }
+	X509_STORE_set_flags(cert_ctx, 0);
+	if (!X509_STORE_CTX_init(csc, cert_ctx, x, NULL))
+    {
+        X509_STORE_free(cert_ctx);
+        X509_STORE_CTX_free(csc);
+		return 0;
+    }
+	if (tstack)
+    {
+        X509_STORE_CTX_trusted_stack(csc, tstack);
+    }
+	ret = X509_verify_cert(csc);
+    X509_STORE_free(cert_ctx);
+	X509_STORE_CTX_free(csc);
+
+    return ret;
+}
+
 /*#defines for i2d and d2i types, which are typed differently
 in openssl-0.9.8 than they are in openssl-0.9.7. This will
 be picked up by the C preprocessor, not the SWIG preprocessor.
