#!/usr/bin/python
#
# Copyright (C) 2009 Chris Newton <redshodan@gmail.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Author: Chris Newton <redshodan@gmail.com>
# $Revision: 34856e984289 $
#

import os, sys, select, pty, termios, socket, threading, struct, fcntl
import errno, signal, re, ssl, subprocess
from optparse import OptionParser

# Command byte:
#  - least significant 3 bits are command.
#  - middle 4 bits are size of data.
#  - most significant bit indicates size is number of size bytes.
CMD_NONE = -1
CMD_DATA = 0
CMD_TTY = 1
CMD_MAX = 7
CMD_CMDS = 1 | 2 | 4
CMD_SIZE_MAX = 15
CMD_SIZE_MAXED = 128

log_file = None
is_server = False

def initLog(name):
    global log_file
    log_file = open("log" + "-" + name, "w+")

# Non-exception throwing list managment functions. Sometimes python takes
# exceptions too far.
def insList(val, list):
    for index in range(len(list)):
        if list[index] == val:
            return
    else:
        list.append(val)

def delList(val, list):
    for index in range(len(list)):
        if list[index] == val:
            del list[index]
            return

def log(*args):
    for arg in args:
        log_file.write("%s " % str(arg))
    log_file.write("\n")
    log_file.flush()

class PipeBuff(object):
    def __init__(self, decoder, cb, do_encode):
        self.decoder = decoder
        self.do_encode = do_encode
        self.cb = cb
        self.reset()

    def reset(self):
        self.data = None
        self.output = None
        self.length = 0
        self.cmd = CMD_NONE

    def toStr(self):
        if self.data:
            data = self.data
        else:
            data = ""
        return "cmd=%d len=%s data='%s' output='%s'" % \
               (self.cmd, str(len(data)), self.data, self.output)

    def filterData(self):
        if self.decoder:
            self.decodeCmd()
        else:
            if self.do_encode:
                self.encodeCmd(CMD_DATA, self.data)
                log("encoded buff: %s" % self.output)
            else:
                log("output buff: %s" % self.output)
                if self.output:
                    self.output = self.output + data
                else:
                    self.output = self.data
                self.data = None
                log("output buff: %s" % self.output)

    def encodeCmd(self, cmd, data):
        if data:
            length = len(data)
            log("length=%d" % length)
            if length <= CMD_SIZE_MAX + 1:
                cmd = cmd + (length << 3)
                output = struct.pack("B", cmd) + data
            else:
                cmd = cmd + CMD_SIZE_MAXED
                log("e-nnl: %d" % length)
                log("e-nl: %d" % socket.htonl(length))
                output = (struct.pack("B", cmd) +
                          struct.pack("I", socket.htonl(length)) + data)
        else:
            output = struct.pack("B", cmd)
        if self.output:
            self.output = self.output + output
        else:
            self.output = output

    def decodeCmd(self):
        if self.cmd == CMD_NONE:
            self.cmd = struct.unpack("B", self.data[0])[0]
            log("unpacked cmd: %d" % self.cmd)
            if self.cmd & CMD_SIZE_MAXED:
                self.length = struct.unpack("I", self.data[1:5])[0]
                self.length = socket.ntohl(self.length)
                self.data = self.data[5:]
            else:
                self.length = self.cmd >> 3
                self.data = self.data[1:]
            self.cmd = self.cmd & CMD_CMDS
        cmd = self.cmd
        ret = False
        if len(self.data) < self.length:
            cmd_data = None
        elif len(self.data) == self.length:
            if self.output:
                self.output = self.output + self.data
            else:
                self.output = self.data
            cmd_data = self.data
            self.data = None
            self.cmd = CMD_NONE
        else:
            if self.output:
                self.output = self.output + self.data[:self.length]
            else:
                self.output = self.data[:self.length]
            cmd_data = self.data[:self.length]
            self.data = self.data[self.length:]
            self.cmd = CMD_NONE
            ret = True
        log("decoded length: %d self.cmd: %d cmd: %d" %
            (self.length, self.cmd, cmd))
        log("decoded data: %s" % self.data)
        log("decoded output: %s" % self.output)
        log("decoded cmd_data: %s" % cmd_data)
        if cmd_data and self.cmd != CMD_DATA:
            self.output = self.cb(cmd, cmd_data)
        if ret:
            log("Recursing decodeCmd")
            return self.decodeCmd()
        else:
            return ret

class Pipe(object):
    def __init__(self, ins, outs, ifd_is_sock, cb, do_encode):
        self.ifd = None
        self.ofd = None
        self.ins = ins
        self.outs = outs
        self.buff = PipeBuff(ifd_is_sock, cb, do_encode)
        self.reader = None

    def reset(self):
        self.buff.reset()

    def setPipes(self, ifd, ofd, iraw, oraw):
        self.ifd = ifd
        self.ofd = ofd
        self.iraw = iraw
        self.oraw = oraw

    def sendCmd(self, cmd, data):
        self.buff.encodeCmd(cmd, data)
        insList(self.ofd, self.outs)
        delList(self.ifd, self.ins)

    def run(self, do_read):
        while self._run(do_read):
            pass
        
    def _run(self, do_read):
        log("Pipe.run(%s)" % str(do_read))
        if do_read:
            try:
                log("starting read(%s)" % str(self.ifd))
                if self.iraw:
                    data = os.read(self.ifd.fileno(), 1024)
                else:
                    data = self.ifd.read(1024)
                if self.buff.data:
                    self.buff.data = self.buff.data + data
                else:
                    self.buff.data = data
                log("read(%s): %d %s" % (str(self.ifd.fileno()), len(data),
                                         data))
            except OSError, e:
                log("read(%s): EXC: %s" % (str(self.ifd.fileno()), str(e)))
                if e.errno == errno.EIO:
                    log("read(%s): EXC: %s" % (str(self.ifd.fileno()), "EIO"))
                    delList(self.ifd, self.ins)
                    self.buff.reset()
                    return False
                elif e.errno == errno.EAGAIN:
                    log("EAGAIN")
                    if not self.buff.output:
                        return False
                else:
                    log("read(%s): EXC: %s:%d" %
                        (str(self.ifd.fileno()), e.errno))
                    raise
            except ssl.SSLError, e:
                if e.errno == 2:
                    # want read
                    log("in read: ssl want read")
                    insList(self.ifd, self.ins)
                    delList(self.ofd, self.outs)
                    return False
                elif e.errno == 3:
                    # want write
                    log("in read: ssl want write")
                    delList(self.ifd, self.ins)
                    insList(self.ofd, self.outs)
                    if not self.buff.output:
                        return False
                else:
                    raise
        if (do_read and ((not self.buff.data) or (not len(self.buff.data)))):
            raise Exception("Connection lost")
        if self.buff.data:
            self.buff.filterData()
        if self.buff.output:
            try:
                log("write(%s) %s" % (str(self.ifd.fileno()), self.buff.output))
                if self.oraw:
                    size = os.write(self.ofd.fileno(), self.buff.output)
                else:
                   size = self.ofd.write(self.buff.output)
                log("write(%s) size %s" % (str(self.ifd.fileno()), str(size)))
            except OSError, e:
                log("write(%s): EXC %s" % (str(self.ifd.fileno()), str(e)))
                if e.errno == errno.EAGAIN:
                    log("write(%s): EXC %s" % (str(self.ifd.fileno()), "EAGAIN"))
                    insList(self.ofd, self.outs)
                    delList(self.ifd, self.ins)
                    return False
            except ssl.SSLError, e:
                if e.errno == 2:
                    # want read
                    log("in write: ssl want read")
                    insList(self.ifd, self.ins)
                    delList(self.ofd, self.outs)
                    return False
                elif e.errno == 3:
                    # want write
                    log("in write: ssl want write")
                    delList(self.ifd, self.ins)
                    insList(self.ofd, self.outs)
                    return False
                else:
                    raise
            if size is not None and size != len(self.buff.output):
                insList(self.ofd, self.outs)
                delList(self.ifd, self.ins)
                self.buff.output = self.buff.output[size:]
                log("write(%s): %s partial %s" % (str(self.ifd.fileno()),
                                                  str(size), self.buff.output))
                return False
            elif size is None:
                raise Exception("Connection lost on write")
            else:
                log("write(%s): reset" % str(self.ifd.fileno()))
                self.buff.reset()
                insList(self.ifd, self.ins)
                delList(self.ofd, self.outs)

        if do_read:
            return True
        else:
            return False

class TTYManager(threading.Thread):
    def __init__(self, fdin, fdout, tty, cmd_cb, extra_fds=[],
                 extra_fds_cb=None):
        threading.Thread.__init__(self)
        self.fdin = fdin
        self.fdout = fdout
        self.tty = tty
        self.ins = []
        self.outs = []
        self.cmd_cb = cmd_cb
        self.extra_fds = extra_fds
        self.extra_fds_cb = extra_fds_cb
        self.inpipe = Pipe(self.ins, self.outs, True, self.cmd_cb, False)
        self.outpipe = Pipe(self.ins, self.outs, False, self.cmd_cb, True)
        self.setDaemon(True)
        self.setup()

    def close(self):
        try:
            self.fdin.close()
        except:
            pass
        try:
            self.fdout.close()
        except:
            pass
        try:
            termios.tcsetattr(self.tty, termios.TCSANOW, self.orig_tty)
            os.close(self.tty)
        except:
            pass

    def setup(self):
        self.orig_tty = termios.tcgetattr(self.tty)
        new = termios.tcgetattr(self.tty)
        new[0] = new[0] | termios.IGNPAR
        new[0] = new[0] & ~(termios.ISTRIP|termios.INLCR|termios.IGNCR|
                            termios.ICRNL|termios.IXON|termios.IXANY|
                            termios.IXOFF)
        new[3] = new[3] & ~(termios.ICANON|termios.ISIG|termios.ECHO|
                            termios.ECHOE|termios.ECHOK|
                            termios.IEXTEN|termios.ECHONL)
        new[1] = new[1] & ~termios.OPOST
        termios.tcsetattr(self.tty.fileno(), termios.TCSANOW, new)

        log("fds: fdin=%d fdout=%d tty=%s" %
            (self.fdin.fileno(), self.fdout.fileno(), self.tty.fileno()))
        
        fcntl.fcntl(self.tty.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)
        fcntl.fcntl(self.fdin.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)
        fcntl.fcntl(self.fdout.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)
        for fd in self.extra_fds:
            fcntl.fcntl(fd.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)

        self.ins.extend([self.fdin, self.tty])
        self.ins.extend(self.extra_fds)
        self.inpipe.setPipes(self.fdin, self.tty, False, True)
        self.outpipe.setPipes(self.tty, self.fdout, True, False)

    def run(self):
        log("Starting TTYManager.run()")
        try:
            while len(self.ins) or len(self.outs):
                if ((len(self.ins) == 1) and (self.ins[0] == self.fdin) and
                    not len(self.outs)):
                    log("breaking out of TTYManager.run")
                    break
                try:
                    ret = select.select(self.ins, self.outs, [], 10.0)
                except select.error, e:
                    if e[0] == 4:
                        log("select err 4")
                        continue
                try:
                    self.logInOuts()
                    for fd in self.extra_fds:
                        if fd in ret[0]:
                            self.extra_fds_cb(fd)
                    if self.fdin in ret[0]:
                        self.inpipe.run(True)
                    if self.tty in ret[1]:
                        self.inpipe.run(False)
                    if self.tty in ret[0]:
                        self.outpipe.run(True)
                    if self.fdout in ret[1]:
                        self.outpipe.run(False)
                except Exception, e:
                    log("I/O exception: %s %s" % (type(e), str(e)))
                    import traceback
                    log(traceback.format_exc())
                    self.close()
                    return
        except Exception, e:
            log("Main loop exception: %s %s" % (type(e), str(e)))
            import traceback
            traceback.print_exc()

    def logInOuts(self):
        msg = ""
        for fd in self.ins:
            msg = "%s, %d" % (msg, fd.fileno())
        log("ins: %s" % msg)
        msg = ""
        for fd in self.outs:
            msg = "%s, %d" % (msg, fd.fileno())
        log("outs: %s" % msg)

    def sendCmd(self, cmd, data):
        self.outpipe.sendCmd(cmd, data)

class Server(object):
    def __init__(self):
        self.started_emacs = False
        self.pipe = None
    
    def run(self):
        try:
            self.pipe = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            self.pipe.connect("/tmp/remacs%d/remacs" % os.geteuid())
            log("connected to emacs server")
            self.pipe.setblocking(0)
            (self.tty, self.slave) = pty.openpty()
            self.tty = os.fdopen(self.tty, "w+")
            fcntl.ioctl(self.tty, termios.TIOCSWINSZ,
                        struct.pack("HHHH", 24, 80, 0, 0))
            self.mgr = TTYManager(sys.stdin, sys.stdout, self.tty, self.cmd_cb,
                                  [self.pipe], self.pipe_cb)
            self.mgr.run()
        except Exception, e:
            print "Main loop exception: %s %s" % (type(e), str(e))
            import traceback
            traceback.print_exc()
        finally:
            self.mgr.close()

    def startEmacs(self, term):
        sendToEmacs("tty", os.ttyname(self.slave), term)
        sendFinish()

    def escape(str):
        ret = []
        if str[0] == "-":
            ret.append("&")
        for c in str:
            if c == " ":
                ret.append("&_")
            elif c == "\n":
                ret.append("&n")
            elif c == "&":
                ret.append("&&")
            else:
                ret.append(c)
        return "".join(ret)

    def sendToEmacs(cmd, *args):
        out = []
        for arg in args:
            out.append(escape(arg.strip()))
        self.pipe.write("-%s %s" % (cmd, " ".join(out)))

    def pipe_cb(self, fd):
        buff = self.pipe.read()
        log("Got from emacs: " + buff)
        
    def cmd_cb(self, cmd, data):
        log("SERVER CMD: %s DATA: %s" % (cmd, data))
        if cmd == CMD_TTY:
            words = {}
            for word in data.split(";"):
                key, val = word.split("=")
                words[key] = val
            buff = struct.pack("HHHH", int(words["row"]), int(words["col"]),
                               0, 0)
            log("winsize %d: %s" % (len(buff), buff))
            log("Setting winsize: %s %s" % (words["row"], words["col"]))
            fcntl.ioctl(self.tty, termios.TIOCSWINSZ, buff)
            if not self.started:
                self.startEmacs(words["term"])
                self.started = True
        elif cmd == CMD_DATA:
            return data

class Client(object):
    def __init__(self, host, transport):
        self.host = host
        self.transport = transport
        self.cmd = self.transport + " -T " + self.host + " remacs --server"
        self.tty = open(os.ttyname(sys.stdin.fileno()), "w+", 0)
        if "TERM" in os.environ:
            self.term = os.environ["TERM"]
        else:
            self.term = "xterm"
        
    def run(self):
        try:
            print "cmd:", self.cmd
            self.pipe = subprocess.Popen(self.cmd, stdin=subprocess.PIPE,
                                         stdout=subprocess.PIPE,
                                         stderr=subprocess.PIPE, shell=True)

            signal.signal(signal.SIGWINCH, self.sigWINCH)

            self.mgr = TTYManager(self.pipe.stdin, self.pipe.stdout,
                                  self.tty, self.cmd_cb)
            self.sigWINCH(0, None)
            self.mgr.run()
        except Exception, e:
            print "Main loop exception: %s %s" % (type(e), str(e))
            import traceback
            traceback.print_exc()
        finally:
            self.mgr.close()

    def sigWINCH(self, signum, frame):
        try:
            buff = 'abcdefgh'
            buff = fcntl.ioctl(self.tty, termios.TIOCGWINSZ, buff)
            (row, col, x, y) = struct.unpack("HHHH", buff)
            log("winsize %d: %s" % (len(buff), buff))
            if not signum and not frame:
                cmd = "term=%s;" % self.term
            else:
                cmd = ""
            cmd = "%srow=%d;col=%d" % (cmd, row, col)
            self.mgr.sendCmd(CMD_TTY, cmd)
        except Exception, e:
            log("sigWINCH: %s" % str(e))
            import traceback
            traceback.print_exc()
            print e

    def cmd_cb(self, cmd, data):
        log("CLIENT CMD: %s DATA: %s" % (cmd, data))
        if cmd == CMD_DATA:
            return data
        else:
            return None

if __name__ == "__main__":
    parser = OptionParser()
    parser.add_option("-s", "--server", action="store_true", dest="server",
                      default=False, help="Run in server mode")
    parser.add_option("-t", "--transport", dest="transport", default="ssh",
                      help="Transport program. ie: ssh")
    (options, args) = parser.parse_args()

    if options.server:
        initLog("server")
        is_server = True
        server = Server()
        server.run()
    elif len(args) != 1:
        parser.print_help()
    else:
        initLog("client")
        client = Client(args[0], options.transport)
        client.run()
