#!/usr/bin/python
#
# Copyright (C) 2009 Chris Newton <redshodan@gmail.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Author: Chris Newton <redshodan@gmail.com>
# $Revision$
#

import os, sys, select, pty, termios, socket, threading, struct, fcntl
import errno, signal
from optparse import OptionParser

# Command byte:
#  - least significant 3 bites are command.
#  - middle 4 bits are size of data.
#  - most significant bit indicates size is number of size bytes.
CMD_NONE = -1
CMD_DATA = 0
CMD_TTY = 1
CMD_MAX = 7
CMD_CMDS = 1 | 2 | 4
CMD_SIZE_MAX = 15
CMD_SIZE_MAXED = 128

log_file = None
is_server = False

def initLog(name):
    global log_file
    log_file = open("log" + "-" + name, "w+")

# Non-exception throwing list managment functions. Sometimes python takes
# exceptions too far.
def insList(val, list):
    for index in range(len(list)):
        if list[index] == val:
            return
    else:
        list.append(val)

def delList(val, list):
    for index in range(len(list)):
        if list[index] == val:
            del list[index]
            return

def escape(str):
    ret = []
    if str[0] == "-":
        ret.append("&")
    for c in str:
        if c == " ":
            ret.append("&_")
        elif c == "\n":
            ret.append("&n")
        elif c == "&":
            ret.append("&&")
        else:
            ret.append(c)
    return "".join(ret)

def sendToEmacs(cmd, *args):
    out = []
    for arg in args:
        out.append(escape(arg.strip()))
    print "-%s %s" % (cmd, " ".join(out)),
    #sys.stdout.flush()

def sendFinish():
    print

def log(*args):
    # if is_server:
    #     #print args
    #     sendToEmacs("msg", *args)
    # else:
    if True:
        for arg in args:
            log_file.write("%s " % str(arg))
        log_file.write("\n")
        log_file.flush()

class PipeBuff(object):
    def __init__(self, decoder, cb):
        self.decoder = decoder
        self.cb = cb
        self.reset()

    def reset(self):
        self.data = None
        self.output = None
        self.length = 0
        self.cmd = CMD_NONE
        self.need_more = True

    def toStr(self):
        return "cmd=%d len=%s data='%s' output='%s'" % \
               (self.cmd, str(len(self.data)), self.data, self.output)

    def filterData(self):
        if self.decoder:
            self.decodeCmd()
        else:
            self.encodeCmd(CMD_DATA, self.data)
            log("encoded buff: %s" % self.output)

    def encodeCmd(self, cmd, data):
        if data:
            length = len(data)
            log("length=%d" % length)
            if length <= CMD_SIZE_MAX + 1:
                cmd = cmd + (length << 3)
                output = struct.pack("B", cmd) + data
            else:
                cmd = cmd + CMD_SIZE_MAXED
                log("e-nnl: %d" % length)
                log("e-nl: %d" % socket.htonl(length))
                output = (struct.pack("B", cmd) +
                          struct.pack("I", socket.htonl(length)) + data)
        else:
            output = struct.pack("B", cmd)
        if self.output:
            self.output = self.output + output
        else:
            self.output = output

    def decodeCmd(self):
        if not self.need_more or self.cmd == CMD_NONE:
            self.cmd = struct.unpack("B", self.data[0])[0]
            log("unpacked cmd: %d" % self.cmd)
            if self.cmd & CMD_SIZE_MAXED:
                for c in self.data[1:5]:
                    log("c %s" % c)
                self.length = struct.unpack("I", self.data[1:5])[0]
                log("d-nl: %d" % self.length)
                self.length = socket.ntohl(self.length)
                log("d-nnl: %d" % self.length)
                log("d-maxed len: %d" % self.length)
                self.data = self.data[5:]
            else:
                self.length = self.cmd >> 3
                self.data = self.data[1:]
            self.cmd = self.cmd & CMD_CMDS
        ret = False
        if len(self.data) < self.length:
            self.need_more = True
            cmd_data = None
        elif len(self.data) == self.length:
            self.output = self.data
            cmd_data = self.data
            self.data = None
        else:
            if self.output:
                self.output = self.output + self.data[:self.length]
            else:
                self.output = self.data[:self.length]
            cmd_data = self.data[:self.length]
            self.data = self.data[self.length:]
            ret = True
        log("decoded length: %d need_more=%s cmd: %d" %
            (self.length, self.need_more, self.cmd))
        log("decoded data: %s" % self.data)
        log("decoded output: %s" % self.output)
        log("decoded cmd_data: %s" % cmd_data)
        if self.cmd != CMD_DATA:
            self.output = self.cb(self.cmd, cmd_data)
        if ret:
            self.cmd = CMD_NONE
            return self.decodeCmd()
        else:
            return ret

class Pipe(object):
    def __init__(self, ins, outs, ifd_is_sock, cb):
        self.ifd = None
        self.ofd = None
        self.ins = ins
        self.outs = outs
        self.buff = PipeBuff(ifd_is_sock, cb)
        self.reader = None

    def reset(self):
        self.buff.reset()

    def setPipes(self, ifd, ofd, iraw, oraw):
        self.ifd = ifd
        self.ofd = ofd
        self.iraw = iraw
        self.oraw = oraw

    def sendCmd(self, cmd, data):
        self.buff.encodeCmd(cmd, data)
        self.buff.need_more = False
        insList(self.ofd, self.outs)
        delList(self.ifd, self.ins)

    def run(self):
        if self.buff.need_more:
            try:
                if self.iraw:
                    self.buff.data = os.read(self.ifd.fileno(), 1024)
                else:
                    self.buff.data = self.ifd.read(1024)
                log("read(%s): %s" % (str(self.ifd.fileno()), self.buff.toStr()))
                if not is_server:
                    if self.buff == r"[>1;1704;0c":
                        self.buff = None
                        return
            except OSError, e:
                log("read(%s): EXC: %s" % (str(self.ifd.fileno()), str(e)))
                if e.errno == errno.EIO:
                    log("read(%s): EXC: %s" % (str(self.ifd.fileno()), "EIO"))
                    delList(self.ifd, self.ins)
                    self.buff.reset()
                    return
                elif e.errno == errno.EAGAIN:
                    return
                else:
                    log("read(%s): EXC: %s:%d" %
                        (str(self.ifd.fileno()), e.errno))
                    raise
        if ((not self.buff.output) and
            ((not self.buff.data) or (not len(self.buff.data)))):
            raise Exception("Connection lost")
        if self.buff.data:
            self.buff.filterData()
        if self.buff.output:
            try:
                log("write(%s) %s" % (str(self.ifd.fileno()), self.buff.output))
                if self.oraw:
                    size = os.write(self.ofd.fileno(), self.buff.output)
                else:
                    size = self.ofd.write(self.buff.output)
                log("write(%s) size %s" % (str(self.ifd.fileno()), str(size)))
                # if size is not None and size > 0:
                #     self.ofd.flush()
            except OSError, e:
                log("write(%s): EXC %s" % (str(self.ifd.fileno()), str(e)))
                if e.errno == errno.EAGAIN:
                    log("write(%s): EXC %s" % (str(self.ifd.fileno()), "EAGAIN"))
                    insList(self.ofd, self.outs)
                    delList(self.ifd, self.ins)
                    return
            if size is not None and size != len(self.buff.output):
                insList(self.ofd, self.outs)
                delList(self.ifd, self.ins)
                self.buff.output = self.buff.output[size:]
                log("write(%s): %s partial %s" % (str(self.ifd.fileno()),
                                                  str(size), self.buff.output))
                return
        
        insList(self.ifd, self.ins)
        delList(self.ofd, self.outs)
        self.buff.reset()

class TTYManager(threading.Thread):
    def __init__(self, id, sock, tty, cmdCB, mgr = None):
        threading.Thread.__init__(self)
        self.id = id
        self.sock = sock
        self.tty = tty
        self.mgr = mgr
        self.ins = []
        self.outs = []
        self.cmdCB = cmdCB
        self.inpipe = Pipe(self.ins, self.outs, True, self.cmdCB)
        self.outpipe = Pipe(self.ins, self.outs, False, self.cmdCB)
        self.setDaemon(True)
        self.setup()

    def close(self):
        try:
            self.sock.close()
        except:
           pass
        try:
            os.close(self.tty)
        except:
            pass
        if self.mgr:
            self.mgr.delManager(self)

    def setup(self):
        new = termios.tcgetattr(self.tty.fileno())
        new[0] = new[0] | termios.IGNPAR
        new[0] = new[0] & ~(termios.ISTRIP|termios.INLCR|termios.IGNCR|
                            termios.ICRNL|termios.IXON|termios.IXANY|
                            termios.IXOFF)
        new[3] = new[3] & ~(termios.ICANON|termios.ISIG|termios.ECHO|
                            termios.ECHOE|termios.ECHOK|
                            termios.IEXTEN|termios.ECHONL)
        new[1] = new[1] & ~termios.OPOST
        termios.tcsetattr(self.tty.fileno(), termios.TCSANOW, new)

        log("fds: sock=%d tty=%s" % (self.sock.fileno(), self.tty.fileno()))
        
        fcntl.fcntl(self.tty.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)
        fcntl.fcntl(self.tty.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)

        self.ins.extend([self.sock, self.tty])
        self.inpipe.setPipes(self.sock, self.tty, False, True)
        self.outpipe.setPipes(self.tty, self.sock, True, False)

    def run(self):
        try:
            while len(self.ins) or len(self.outs):
                if ((len(self.ins) == 1) and (self.ins[0] == self.sock) and
                    not len(self.outs)):
                    break
                try:
                    ret = select.select(self.ins, self.outs, [], 10.0)
                except select.error, e:
                    if e[0] == 4:
                        continue
                try:
                    if (self.sock in ret[0]) or (self.tty in ret[1]):
                        self.inpipe.run()
                    if (self.tty in ret[0]) or (self.sock in ret[1]):
                        self.outpipe.run()
                except Exception, e:
                    log("Socket exception: %s %s" % (type(e), str(e)))
                    self.close()
                    return
        except Exception, e:
            log("Main loop exception: %s %s" % (type(e), str(e)))
            import traceback
            traceback.print_exc()

    def sendCmd(self, cmd, data):
        self.outpipe.sendCmd(cmd, data)

class Server(object):
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.sock = None
        self.ttys = []

    def run(self):
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.bind((self.host, self.port))
            self.sock.listen(1)
            self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER,
                                 struct.pack("ii", 1, 0))

            ins = [self.sock, sys.stdin]
            outs = []
            errs = []
            while True:
                try:
                    ret = select.select(ins, outs, errs)
                except select.error, e:
                    if e[0] == 4:
                        continue
                if self.sock in ret[0]:
                    conn, addr = self.sock.accept()
                    log("New connection from: %s" % str(addr))
                    conn = self.sslify(conn, addr)
                    if not conn:
                        continue
                    (self.tty, slave) = pty.openpty()
                    self.tty = os.fdopen(self.tty, "w+")
                    fcntl.ioctl(self.tty, termios.TIOCSWINSZ,
                                struct.pack("HHHH", 24, 80, 0, 0))
                    #os.close(slave)
                    mgr = TTYManager(len(self.ttys), conn, self.tty,
                                     self.cmdCB, self)
                    self.addManager(mgr)
                    sendToEmacs("tty", os.ttyname(slave), "xterm")
                    sendFinish()
                    mgr.start()
                if sys.stdin in ret[0]:
                    buff = sys.stdin.read()
                    log("from emacs: %s" % buff)
        except Exception, e:
            log("Main loop exception: %s %s" % (type(e), str(e)))
            import traceback
            traceback.print_exc()
            try:
                self.sock.close()
            except:
                pass
            for tty in self.ttys:
                tty.close()

    def addManager(self, mgr):
        self.ttys.append(mgr)

    def delManager(self, mgr):
        delList(mgr, self.ttys)

    def sslify(self, conn, addr):
        try:
            import ssl
            try:
                return ssl.wrap_socket(
                    conn, ssl_version=ssl.PROTOCOL_TLSv1, server_side=True,
                    keyfile="cert.pem", certfile="cert.pem")
            except Exception, e:
                log("SSL failed for '%s': %s" % (str(addr), str(e)))
                conn.close()
                return None
        except:
            try:
                return socket.ssl(conn)
            except Exception, e:
                log("SSL failed for '%s': %s" % (str(addr), str(e)))
                conn.close()
                return None

    def cmdCB(self, cmd, data):
        log("SERVER CMD: %s DATA: %s" % (cmd, data))
        if cmd == CMD_TTY:
            words = {}
            for word in data.split(";"):
                key, val = word.split("=")
                words[key] = val
            buff = struct.pack("HHHH", int(words["row"]), int(words["col"]),
                               0, 0)
            log("Setting winsize: %s %s" % (words["row"], words["col"]))
            fcntl.ioctl(self.tty, termios.TIOCSWINSZ, buff)

class Client(object):
    def __init__(self, host, port):
        self.addr = (host, port)
        self.sock = None
        self.tty = open(os.ttyname(sys.stdin.fileno()), "w+", 0)

    def run(self):
        self.orig_tty = termios.tcgetattr(self.tty)
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect(self.addr)
            self.sock = self.sslify()

            signal.signal(signal.SIGWINCH, self.sigWINCH)

            self.mgr = TTYManager(0, self.sock, self.tty, self.cmdCB)
            self.sigWINCH(0, None)
            self.mgr.run()
        except Exception, e:
            termios.tcsetattr(self.tty, termios.TCSANOW, self.orig_tty)
            print "Main loop exception: %s %s" % (type(e), str(e))
            import traceback
            traceback.print_exc()
            self.mgr.close()
        finally:
            termios.tcsetattr(self.tty, termios.TCSANOW, self.orig_tty)

    def sigWINCH(self, signum, frame):
        try:
            buff = 'abcdefgh'
            buff = fcntl.ioctl(self.tty, termios.TIOCGWINSZ, buff)
            (row, col, x, y) = struct.unpack("HHHH", buff)
            self.mgr.sendCmd(CMD_TTY, "row=%d;col=%d" % (row, col))
        except Exception, e:
            log("sigWINCH: %s" % str(e))
            import traceback
            traceback.print_exc()
            print e

    def sslify(self):
        try:
            import ssl
            try:
                return ssl.wrap_socket(
                    self.sock, ssl_version=ssl.PROTOCOL_TLSv1, server_side=False)
            except Exception, e:
                print "SSL failed for '%s': %s" % (str(self.addr), str(e))
                self.sock.close()
                return None
        except:
            try:
                return socket.ssl(self.sock)
            except Exception, e:
                print "SSL failed for '%s': %s" % (str(self.addr), str(e))
                self.sock.close()
                return None

    def cmdCB(self, cmd, data):
        log("CLIENT CMD: %s DATA: %s" % (cmd, data))

if __name__ == "__main__":
    if "--server" in sys.argv:
        initLog("server")
        is_server = True
        server = Server("0.0.0.0", 4334)
        server.run()
    else:
        initLog("client")
        client = Client("localhost", 4334)
        client.run()
