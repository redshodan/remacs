#!/usr/bin/python
#
# Copyright (C) 2009 Chris Newton <redshodan@gmail.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#
# Author: Chris Newton <redshodan@gmail.com>
# $Revision$
#

import os, sys, select, pty, termios, socket, struct, fcntl
import errno, signal, subprocess, time
from xml.dom import minidom as dom
from optparse import OptionParser


# Command byte:
#  - least significant 3 bits are command.
#  - middle 4 bits are size of data.
#  - most significant bit indicates size is number of size bytes.
CMD_NONE = -1
CMD_TTY = 0
CMD_CMD = 1
CMD_BLOCK = 2
CMD_MAX = 7
CMD_CMDS = 7
CMD_SIZE_MAX = 15
CMD_SIZE_MAXED = 128

log_file = None
is_server = False

# Bleck
impl = dom.getDOMImplementation()
d = impl.createDocument(None, None, None)
XML_PREFIX = len(d.toxml())
d.unlink()
del d
del impl

def initLog(name):
    global log_file
    log_file = open("log" + "-" + name, "w+")

# Non-exception throwing list managment functions. Sometimes python takes
# exceptions too far.
def insList(val, list):
    for index in range(len(list)):
        if list[index] == val:
            return
    else:
        list.append(val)

def delList(val, list):
    for index in range(len(list)):
        if list[index] == val:
            del list[index]
            return

def toxml(elem):
    return elem.toxml()[XML_PREFIX:]

def log(*args):
    for arg in args:
        log_file.write("%d: %s " % (time.time(), str(arg)))
    log_file.write("\n")
    log_file.flush()

class PipeBuff(object):
    def __init__(self, cb, decoder, encoder):
        self.cb = cb
        self.decoder = decoder
        self.encoder = encoder
        self.data = None
        self.output = None
        self.length = -1
        self.cmd = CMD_NONE

    def toStr(self):
        if self.data:
            data = self.data
        else:
            data = ""
        return "cmd=%d len=%s data='%s' output='%s'" % \
               (self.cmd, str(len(data)), self.data, self.output)

    def filterData(self):
        if self.decoder:
            self.decodeCmd()
        else:
            if self.encoder:
                self.encodeCmd(CMD_TTY, self.data)
                self.data = None
                log("encoded buff: %s" % self.output)
            else:
                log("output buff: %s" % self.output)
                if self.output:
                    self.output = self.output + data
                else:
                    self.output = self.data
                self.data = None
                log("output buff: %s" % self.output)

    def encodeCmd(self, cmd, data):
        log("encodeCmd:%d %s" % (cmd, data))
        if data:
            length = len(data)
            log("length=%d" % length)
            if length <= CMD_SIZE_MAX:
                cmd = cmd + (length << 3)
                log("cmd: %d" % cmd)
                output = struct.pack("B", cmd) + data
            else:
                cmd = cmd + CMD_SIZE_MAXED
                log("e-nnl: %d" % length)
                log("e-nl: %d" % socket.htonl(length))
                output = (struct.pack("B", cmd) +
                          struct.pack("I", socket.htonl(length)) + data)
        else:
            output = struct.pack("B", cmd)
        if self.output:
            self.output = self.output + output
        else:
            self.output = output

    def decodeCmd(self):
        log("Starting decodeCmd: data len: %d" % len(self.data))
        if self.cmd == CMD_NONE:
            self.cmd = struct.unpack("B", self.data[0])[0]
            self.data = self.data[1:]
            log("unpacked cmd: %d" % self.cmd)
            log("data len: %d" % len(self.data))
        if self.length == -1:
            if self.cmd & CMD_SIZE_MAXED:
                if len(self.data) < 4:
                    log("dont have enough for length")
                    return False
                self.length = struct.unpack("I", self.data[:4])[0]
                self.length = socket.ntohl(self.length)
                self.data = self.data[4:]
            else:
                self.length = self.cmd >> 3
            self.cmd = self.cmd & CMD_CMDS
            log("setting cmd to: %d" % self.cmd)
        cmd = self.cmd
        ret = False
        cmd_data = None
        if len(self.data) == self.length:
            log("data and length same size")
            cmd_data = self.data
            self.data = None
            self.cmd = CMD_NONE
            self.length = -1
        elif len(self.data) > self.length:
            log("extra data: length=%d data len=%d" %
                (self.length, len(self.data)))
            cmd_data = self.data[:self.length]
            self.data = self.data[self.length:]
            self.cmd = CMD_NONE
            self.length = -1
            ret = True
        if (cmd_data and (cmd != CMD_TTY)):
            cmd_data = self.cb(cmd, cmd_data)
        if cmd_data:
            if self.output:
                self.output = self.output + cmd_data
            else:
                self.output = cmd_data
        log("decoded length: %d self.cmd: %d cmd: %d" %
            (self.length, self.cmd, cmd))
        log("decoded data: %s" % self.data)
        if self.data:
            log("decoded data len: %d" % len(self.data))
        log("decoded output: %s" % self.output)
        if self.output:
            log("output len: %d" % len(self.output))
        log("decoded cmd_data: %s" % cmd_data)
        if cmd_data:
            log("cmd_data len: %d" % len(cmd_data))
        if ret:
            log("Recursing decodeCmd")
            return self.decodeCmd()
        else:
            log("Leaving decodeCmd")
            return ret

class Pipe(object):
    def __init__(self, ins, outs, cb, decoder, encoder):
        self.ifd = None
        self.ofd = None
        self.ins = ins
        self.outs = outs
        self.buff = PipeBuff(cb, decoder, encoder)
        self.reader = None

    def setPipes(self, ifd, ofd):
        self.ifd = ifd
        self.ofd = ofd

    def sendCmd(self, cmd, data):
        self.buff.encodeCmd(cmd, data)
        insList(self.ofd, self.outs)
        delList(self.ifd, self.ins)

    def run(self, do_read):
        while self._run(do_read):
            pass
        
    def _run(self, do_read):
        log("Pipe.run(%s)" % str(do_read))
        if do_read:
            data = None
            try:
                log("starting read(%s)" % str(self.ifd))
                data = os.read(self.ifd, 1024)
                if data and len(data):
                    if self.buff.data:
                        self.buff.data = self.buff.data + data
                    else:
                        self.buff.data = data
                log("read(%s): %s %s" % (str(self.ifd), len(data), data))
            except OSError, e:
                # log("read(%s): EXC: %s" % (str(self.ifd), str(e)))
                if e.errno == errno.EIO:
                    log("read(%s): EXC: %s" % (str(self.ifd), "EIO"))
                    delList(self.ifd, self.ins)
                    return False
                elif e.errno == errno.EAGAIN:
                    log("EAGAIN")
                    if not self.buff.output:
                        return False
                else:
                    log("read(%s): EXC: %s:%d" %
                        (str(self.ifd), e.errno))
                    raise
            if ((not data) or (not len(data))):
                raise Exception("Connection lost")
        if self.buff.data:
            self.buff.filterData()
        if self.buff.output:
            try:
                log("write(%s) %s" % (str(self.ofd), self.buff.output))
                size = os.write(self.ofd, self.buff.output)
                log("write(%s) size %s" % (str(self.ofd), str(size)))
            except OSError, e:
                log("write(%s): EXC %s" % (str(self.ofd), str(e)))
                if e.errno == errno.EAGAIN:
                    log("write(%s): EXC %s" % (str(self.ofd), "EAGAIN"))
                    insList(self.ofd, self.outs)
                    delList(self.ifd, self.ins)
                    return False
            if size is None:
                raise Exception("Connection lost on write")
            elif size > 0:
                if size != len(self.buff.output):
                    insList(self.ofd, self.outs)
                    delList(self.ifd, self.ins)
                    self.buff.output = self.buff.output[size:]
                    log("write(%s): %s partial %s" % (str(self.ofd),
                                                      str(size), self.buff.output))
                    return False
                else:
                    log("write(%s): reset" % str(self.ofd))
                    self.buff.output = None
                    insList(self.ifd, self.ins)
                    delList(self.ofd, self.outs)

        if do_read:
            return True
        else:
            return False

class TTYManager(object):
    def __init__(self, fdin, fdout, tty, cmd_cb, extra_fds=[],
                 extra_fds_cb=None):
        self.fdin = fdin
        self.fdout = fdout
        self.tty = tty
        self.ins = []
        self.outs = []
        self.cmd_cb = cmd_cb
        self.extra_fds = extra_fds
        self.extra_fds_cb = extra_fds_cb
        self.inpipe = Pipe(self.ins, self.outs, self.cmd_cb, True, False)
        self.outpipe = Pipe(self.ins, self.outs, self.cmd_cb, False, True)
        self.setup()

    def close(self):
        try:
            os.close(self.fdin)
        except:
            pass
        try:
            os.close(self.fdout)
        except:
            pass
        try:
            termios.tcsetattr(self.tty, termios.TCSANOW, self.orig_tty)
            os.close(self.tty)
        except:
            pass

    def setup(self):
        self.orig_tty = termios.tcgetattr(self.tty)
        new = termios.tcgetattr(self.tty)
        new[0] = new[0] | termios.IGNPAR
        new[0] = new[0] & ~(termios.ISTRIP|termios.INLCR|termios.IGNCR|
                            termios.ICRNL|termios.IXON|termios.IXANY|
                            termios.IXOFF)
        new[3] = new[3] & ~(termios.ICANON|termios.ISIG|termios.ECHO|
                            termios.ECHOE|termios.ECHOK|
                            termios.IEXTEN|termios.ECHONL)
        new[1] = new[1] & ~termios.OPOST
        termios.tcsetattr(self.tty, termios.TCSANOW, new)

        log("fds: fdin=%d fdout=%d tty=%s" %
            (self.fdin, self.fdout, self.tty))
        
        fcntl.fcntl(self.tty, fcntl.F_SETFL, os.O_NONBLOCK)
        fcntl.fcntl(self.fdin, fcntl.F_SETFL, os.O_NONBLOCK)
        fcntl.fcntl(self.fdout, fcntl.F_SETFL, os.O_NONBLOCK)
        for fd in self.extra_fds:
            fcntl.fcntl(fd, fcntl.F_SETFL, os.O_NONBLOCK)

        self.ins.extend([self.fdin, self.tty])
        self.ins.extend(self.extra_fds)
        self.inpipe.setPipes(self.fdin, self.tty)
        self.outpipe.setPipes(self.tty, self.fdout)

    def run(self):
        log("Starting TTYManager.run()")
        try:
            while len(self.ins) or len(self.outs):
                if ((len(self.ins) == 1) and (self.ins[0] == self.fdin) and
                    not len(self.outs)):
                    log("breaking out of TTYManager.run")
                    break
                try:
                    ret = select.select(self.ins, self.outs, [], 10.0)
                    log("select returned: %s" % (str(ret)))
                except select.error, e:
                    if e[0] == 4:
                        log("select err 4")
                        continue
                try:
                    self.logInOuts()
                    for fd in self.extra_fds:
                        if fd in ret[0]:
                            self.extra_fds_cb(fd)
                    if self.fdin in ret[0]:
                        self.inpipe.run(True)
                    if self.tty in ret[1]:
                        self.inpipe.run(False)
                    if self.tty in ret[0]:
                        self.outpipe.run(True)
                    if self.fdout in ret[1]:
                        self.outpipe.run(False)
                except Exception, e:
                    log("I/O exception: %s %s" % (type(e), str(e)))
                    import traceback
                    log(traceback.format_exc())
                    self.close()
                    return
        except Exception, e:
            log("Main loop exception: %s %s" % (type(e), str(e)))
            import traceback
            traceback.print_exc()
            raise

    def logInOuts(self):
        msg = ""
        for fd in self.ins:
            if len(msg):
                msg = "%s, %s" % (msg, str(fd))
            else:
                msg = "%s" % str(fd)
        log("ins: %s" % msg)
        msg = ""
        for fd in self.outs:
            if len(msg):
                msg = "%s, %s" % (msg, str(fd))
            else:
                msg = "%s" % str(fd)
        log("outs: %s" % msg)
        log("IN: %s" % self.inpipe.buff.toStr())
        log("OUT: %s" % self.outpipe.buff.toStr())

    def sendCmd(self, cmd, data):
        self.outpipe.sendCmd(cmd, data)

class Server(object):
    def __init__(self):
        self.started = False
        self.sock = None
        self.pipe = None
        self.emacs_pid = None
    
    def run(self):
        try:
            self.sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            self.sock.connect("/tmp/remacs%d/remacs" % os.geteuid())
            log("connected to emacs server")
            self.sock.setblocking(0)
            log("sock fd=%d" % self.sock.fileno())
            self.pipe = self.sock.fileno()
            log("sock pipe fd: %d" % self.pipe)
            (self.tty, self.slave) = pty.openpty()
            fcntl.ioctl(self.tty, termios.TIOCSWINSZ,
                        struct.pack("HHHH", 24, 80, 0, 0))
            self.mgr = TTYManager(sys.stdin.fileno(), sys.stdout.fileno(),
                                  self.tty, self.cmd_cb,
                                  [self.pipe], self.pipe_cb)
            self.mgr.run()
        except Exception, e:
            print "Main loop exception: %s %s" % (type(e), str(e))
            import traceback
            traceback.print_exc()
        finally:
            self.mgr.close()

    def sendToEmacs(self, cmd):
        buff = cmd + "\000"
        log("sendToEmacs:" + buff)
        os.write(self.pipe, buff)

    def receivedFromEmacs(self, buff):
        log("Received from emacs: %s" % buff)
        d = dom.parseString(buff)
        elem = d.firstChild
        if elem.nodeName == "emacs":
            self.emacs_pid = elem.getAttribute("pid")
            log("Emacs PID=%s" % self.emacs_pid)
        elif elem.nodeName == "notify":
            self.mgr.sendCmd(CMD_CMD, buff)
        else:
            log("Invalid command from emacs")
        d.unlink()

    def pipe_cb(self, fd):
        log("pipe_cb")
        buff = None
        try:
            buff = os.read(self.pipe, 4096)
            log("pipe_cb: read: %d: %s" % (len(buff), buff))
        except OSError, e:
            if e.errno == errno.EAGAIN:
                log("pipe_cb: EAGAIN")
                return
            else:
                log("pipe_cb: EXCEPT: %s" % e)
                raise
        if buff:
            for line in buff.split("\000"):
                if line and len(line):
                    self.receivedFromEmacs(line)
        else:
            raise Exception("Lost connection to emacs")
        
    def cmd_cb(self, cmd, data):
        log("SERVER CMD: %s DATA: %s" % (cmd, data))
        if cmd == CMD_TTY:
            return data
        elif cmd == CMD_CMD:
            d = dom.parseString(data)
            elem = d.firstChild
            if elem.nodeName == "setup":
                tty = elem.getElementsByTagName("tty")
                if tty:
                    tty = tty[0]
                    row = int(tty.getAttribute("row"))
                    col = int(tty.getAttribute("col"))
                    buff = struct.pack("HHHH", row, col, 0, 0)
                    log("Setting winsize: %s %s" % (row, col))
                    fcntl.ioctl(self.tty, termios.TIOCSWINSZ, buff)
                    tty.setAttribute("name", os.ttyname(self.slave))
                if not self.started:
                    self.sendToEmacs(toxml(d))
                    self.started = True
            else:
                log("Unkown command: " + data)
            d.unlink()

class Client(object):
    def __init__(self, host, transport):
        self.host = host
        self.transport = transport
        self.cmd = self.transport + " -T " + self.host + " remacs --server"
        self.tty = open(os.ttyname(sys.stdin.fileno()), "w+", 0)
        if "TERM" in os.environ:
            self.term = os.environ["TERM"]
        else:
            self.term = "xterm"
        log("ssh cmd: %s" % self.cmd)
        
    def run(self):
        try:
            print "cmd:", self.cmd
            self.pipe = subprocess.Popen(self.cmd, stdin=subprocess.PIPE,
                                         stdout=subprocess.PIPE,
                                         stderr=subprocess.PIPE, shell=True)

            signal.signal(signal.SIGWINCH, self.sigWINCH)
            log("pipe.stdin: %d %s" % (self.pipe.stdin.fileno(),
                                       str(self.pipe.stdin)))
            log("pipe.stdout: %d %s" % (self.pipe.stdout.fileno(),
                                        str(self.pipe.stdout)))
            self.mgr = TTYManager(self.pipe.stdout.fileno(),
                                  self.pipe.stdin.fileno(),
                                  self.tty.fileno(), self.cmd_cb)
            self.sigWINCH()
            self.mgr.run()
        except Exception, e:
            print "Main loop exception: %s %s" % (type(e), str(e))
            import traceback
            traceback.print_exc()
        finally:
            self.mgr.close()

    def sigWINCH(self, signum=None, frame=None):
        try:
            buff = 'abcdefgh'
            buff = fcntl.ioctl(self.tty, termios.TIOCGWINSZ, buff)
            (row, col, x, y) = struct.unpack("HHHH", buff)
            log("winsize %d: %s" % (len(buff), buff))
            self.mgr.sendCmd(
                CMD_CMD, "<setup><tty term='%s' row='%d' col='%d'/></setup>" %
                (self.term, row, col))
        except Exception, e:
            log("sigWINCH: %s" % str(e))
            import traceback
            traceback.print_exc()
            print e

    def cmd_cb(self, cmd, data):
        log("CLIENT CMD: %s DATA:%d %s" % (cmd, len(data), data))
        if cmd == CMD_TTY:
            return data
        else:
            return None

if __name__ == "__main__":
    parser = OptionParser()
    parser.add_option("-s", "--server", action="store_true", dest="server",
                      default=False, help="Run in server mode")
    parser.add_option("-t", "--transport", dest="transport", default="ssh",
                      help="Transport program. ie: ssh")
    (options, args) = parser.parse_args()

    if options.server:
        initLog("server")
        is_server = True
        server = Server()
        server.run()
    elif len(args) != 1:
        parser.print_help()
    else:
        initLog("client")
        client = Client(args[0], options.transport)
        client.run()
